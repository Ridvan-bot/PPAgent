---
description: TypeScript and Node.js patterns for this project
globs: "**/*.ts"
alwaysApply: false
---

# TypeScript & Node.js Patterns

## Error handling

```typescript
// Prefer typed errors and cause chain
class AppError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    options?: ErrorOptions
  ) {
    super(message, options);
    this.name = "AppError";
  }
}

// In async code: log and rethrow or return Result type
try {
  const data = await fetchFromApi();
  return data;
} catch (e) {
  logger.error("fetch failed", { error: e, url });
  throw new AppError("Fetch failed", "FETCH_ERROR", { cause: e });
}
```

## Async and modules

- Use top-level `await` in ESM where it simplifies startup.
- Prefer `async` functions that return `Promise<T>`; avoid mixing callbacks and promises in the same API.

## Imports

- Use path imports from project root (e.g. `#/utils/logger`) if aliases are configured; otherwise relative paths.
- Prefer named exports for utilities and types; default export for single-purpose entry modules.

## Node-specific

- Use `process.env` only at app boundary; pass config as arguments or a config object into functions.
- Prefer `Readonly<T>` for config objects that should not be mutated after init.
